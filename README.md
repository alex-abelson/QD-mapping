
# Mapping, defect classification, and structural quantification of nanoparticle (NP) superlattice images.

## Alex Abelson, PhD
## alexabelson9@gmail.com


### Description
This sofwtware package takes electron microscopy images of NP superlattices and generates a series of useful graphical and numerical outputs. There are three key components: 

1. Identify the x,y position of NPs in the image. This is achieved using two separate steps:
 - a) First, NPs are coarsely identified using a blob-detection algorithm in Sci-Kit image.  
 - b) Second, the position is refined to sub-pixel resolution using a simple 2D Gaussian fitting approach (SciPy Optimize Package; convert 2D to 1D and use a least squares algorithm). 

2. Calculate the Voronoi decomposition of the NP array (SciPy Spatial Package). From this, a variety of local SL structural metrics can be extracted and catalogued for each NP in the image. The Voronoi decomp. is the key computational tool that enables quantification of the local SL structure.

3. Classify NPs in the image based on various attributes of their local SL structure. This is accomplished using a SciKit-Learn Clustering package (DBSCAN). The input design matrix contains features generated by the Voronoi decomposition.

	Finally, quantitative or graphical information can be extracted from either all NPs, or individual NP classes.

	Challenge: There are a variety of ways of evaluating the structural order/disorder of a lattice. Additional functionalities can be added, although inter-dependencies between the three main components of the program necessitate care in adding or removing functionality.

### Required packages:
- Python 3.0 and higher.
- Matplotlib
- Scipy
- Sci-kit Learn

 *These all come standard if you have the Anaconda Distrbution Platform. I run my code through the Anaconda prompt.

### How to install and run the project: 
1. Download the library of python scripts and save them to a folder on your computer.
2. Open the script titled 'runfile.py' and make any necessary settings changes (vide infra). 
3. Navigate in the Anaconda prompt to the folder containing the scripts, then run: /python runfile.py


### Description of contents and functionality:

Note about software structure: The software is designed so that there are 4 scripts (Scripts 1-4) that contain functions that never need user input. One should almost never need to open those scripts to modify the code. All of the user input and the actual flow of code is contained in runfile.py.


#### Script 1. findParticles.py
- Description: Contains a single function responsible for the identification of particles with single-pixel resolution (Step 1a).
- Input: Image file, a tiff.
- Output: returns the x,y positions of each NP as a 2D numpy array.



#### Script 2. subpixel.py
- Description: Calculates the subpixel position of NPs, starting with the output from Script 1 as an initial guess.
- Input: The output from FindBlobs() located in Script 1. x,y positions of each NP.
- Output: An .npz file entitled "centroid_subpixel**.npz" that contains the updates, subpixel resolution centroid positions of each NP.



#### Script 3. designMatrix.py
- Description: Performs the Voronoi decomposition, then extracts structural metrics and returns them as the outputs of various functions. Descriptions of the various functions and their outputs are provided in-code.
- Input: Subpixel centroid .npz file. 
- Output: Various structural metrics as 1D numpy arrays. These are compiled in runfile.py into the design matrix (vide infra).



#### Script 4. clusterAnalysis.py
- Description: Classifies particles in the images based on their structural feature values.
- Input: The design matrix assembled from various outputs of Script 3 functions.
- Output: Class labels for each of the NPs. NPs in different classes can be removed in runfile.py



#### Script 5. runfile.py
- Description: Contains the run functionality of the code; brings together components from Scripts 1-4 to actually do the whole process.
- Input: (see below).
- Output: (see below).

## Using The Code
**Using runfile.py to modify and run the code.**





Acknowledgements: This project was conceived of and developed while working in the laboratory of Matt Law at UC Irvine. Caroline Qian provided many of the images used to validate the software.



 

	
